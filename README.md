## Supplemental Material
## Weighing the Evidence: On Relationship Types in Microservice Extraction

## Index
1. [About](#about)
2. [Benchmark Applications](#benchmark-applications)
3. [Experimental Data](experimentalData) 
4. [Implementation](#implementation)

## About

The microservice-based architecture – a SOA-inspired principle of dividing systems into components that communicate with each other using language-agnostic APIs – has gained increased popularity in industry. Yet, migrating a monolithic application to microservices is a challenging task. A number of automated microservice extraction techniques have been proposed to help developers with the migration complexity. These techniques, at large, construct a graph-based representation of an application and cluster its elements into service candidates. The techniques vary by the types of relationships between application elements that they consider – structural, semantic term similarity, and evolutionary – with each technique utilizing a fixed subset of these relationship types.

Our experience interacting with industry practitioners shows that the relationships prioritized throughout the decomposition process are usually application-specific. That is, there is no one-size-fits-all decomposition solution that is always superior to others. Driven by this insight, we propose a framework that allows the user to prioritize relationship types for a particular input application. We instantiate the framework with multiple relationship types and use it to decompose three open-source applications that have both a monolithic and microservice-based version available to us. We analyze the decompositions produced by our framework and show that the decompositions closest to the manually produced versions prioritize different relationships, supporting our conclusion that there is no fixed set of relationships that works for all microservice-extraction goals.

This repository houses the data and results we collected whilst running our experiments. It also includes the code we used for extracting microservice candidates, alongside instructions for configuring, running, and modifying the code.

A frontend for this code is deployed to [http://wem-web.herokuapp.com/](http://wem-web.herokuapp.com/) -- you can view PartsUnlimitedMRP (with the exclusion of the Dealer classes) and try out different relationship type prioritizations through this UI!  

## Benchmark Applications 

*Note that in our paper, we refer to the microservice-based versions of the benchmarks as the "expected" versions.*

#### PartsUnlimitedMRP

- [Monolithic Version](https://github.com/microsoft/PartsUnlimitedMRP) 
- [Microservice-based Version](https://github.com/microsoft/PartsUnlimitedMRPmicro)

#### JPetstore
- [Monolithic Version](https://github.com/mybatis/jpetstore-6) 
- [Microservice-based Version](https://github.com/research-iobserve/jpetstore-6/tree/distributed-jpetstore)

#### Everest
- [Monolithic Version](https://github.com/arun-gupta/microservices/tree/master/monolith/everest) 
- [Microservice-based Version](https://github.com/arun-gupta/microservices/tree/master/microservice)

## Experimental Data
All data collected and used in the experiments for this paper can be found [here](experimentalData/).

`experimentalData/dependencyGraphs`
- Contains static, dynamic, and evolutionary graphs that represent the monolithic versions of our [benchmark applications](#benchmark-applications).

`experimentalData/expectedCandidates`
- Contains architectural descriptions (in Rigi Standard Format) of the expected, manually-produced microservice-based versions of our [benchmark applications](#benchmark-applications).

`experimentalData/producedCandidates`
- Contains architectural descriptions (in Rigi Standard Format) of the microservice candidates generated by running the Bunch clustering algorithm on static, dynamic, and evolutionary dependencies extracted from our [benchmark applications](#benchmark-applications).

## Framework Implementation

Source code for the implementation of the framework we used for the paper can be found [here](framework-backend/).
For demonstration purposes, we've implemented a graphical user interface that you can use to view PartsUnlimitedMRP. Code for the frontend can be found [here](framework-frontend/)

**Using our approach:** 
1. Extract a class graph that represents your monolithic application, and weight the edges based on the relationship type of your choosing (e.g. # static inter-class method calls, # dynamic inter-class method calls, evolutionary similarity, etc). Class graph must be written in Module Dependency Graph format and must be stored as a .CSV file.
2. Feed the files generated in steps 1 to the clustering algorithm of your choosing. Additional configuration of the clustering algorithm may be required. This repository contains an implementation of the Bunch clustering algorithm that you may use to produce microservice candidates. Detailed instructions for running this algorithm are included below.

**To cluster using Bunch:**
- `cd framework-backend && cd src`
- run `npm start`
- hit the api (`localhost:8080/<application-name>/<static>/<dynamic>/<classname>/<classterm>/<commit>/<contributor>`) with the name of the application you wish to decompose + the prioritizations of each relationship type 
  - e.g. if I would like to decompose application "PartsUnlimitedMRP" w/ 80% prioritization on static, 20% prioritization on dynamic, then I would hit the following api: 
    - `localhost:8080/PartsUnlimitedMRP/80/20/0/0/0/0`
    - result should be returned in the form of a file in Rigi Standard Format
